# Huffman--
用哈夫曼编码实现的一个文件压缩小程序，自己锻炼写着玩
哈夫曼树

结点
路径
长度
权  ：节点上有意义的实数，收费站的收费金额  某个数据出现的概率，频率
结点带权路径长度 ： 权 * 节点路径长度
WPL 树的带权路径长度： 所以叶子节点的带权路径长度有之和  完成的效率

所以 又叫作最优二叉树

哈夫曼树的构造：
1. 权值排序，最小的俩个结点合并生成父1
 2. 比较父1与剩下小的俩个节点的大小，若父1 <=  俩个中任一个，向上伸展
3.若父1 > 俩个数  并列伸展 ：俩数再生成树父2
4，重复2，3步骤，父1为父1，父2中小的节点。
最好将小的节点放在左边，大的放在右边。

其实就是排序问题，永远将最小的俩个数相加，生成的数也放在序列中。编程用堆实现，效率最高


哈夫曼树的特点：
1.没有度为0的结点：构造时俩俩构建
2.n个叶子结点的哈夫曼树共有2n-1个结点
3.哈夫曼树的非叶子结点的左右子树交换后仍是哈夫曼树。
4.多个相同权值的会构造出不同的俩颗树，但WPL都一样。
5.根节点的权是所有叶子节点的权的和。

哈夫曼编码

等长码，浪费空间
频率=权 
方式：
1.等长的ASCII编码： 58 * 8 =464位(bit)
2.等长3位码：58*3 = 174位
3.不等长编码：出现频率高的字符编码短些，出现频率低的字符编码长些 （编码有限，一定会有长编码）

but:不等长编码具有二义性
so，用前缀码来避免二义性。（任何编码都不是其他编码的前缀），1 0  10
soso，可以用二叉树来构造前缀码，将字符都放在叶子结点上就行了。
sososso，用最优二叉树(哈夫曼树)，效率最高，即编码最短。
 概念替换：
 权 ：字符出现的次数，频率
路径长度：字符的编码长度
结点带权路径长度，权重：每个字符最后所用的编码长度
WPL：整个文本的编码长度。

文件压缩项目

1.统计文本字符种类，个数
2.根据字符频率建树
3.保存各字符的哈夫曼编码，根据配置文件来存放
4.压缩，编码替换
5.利用保存好的配置文件，恢复源文件
6.测试




